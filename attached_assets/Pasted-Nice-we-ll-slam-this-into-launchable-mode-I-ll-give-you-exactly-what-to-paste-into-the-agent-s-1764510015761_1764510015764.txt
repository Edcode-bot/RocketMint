Nice ‚Äî we‚Äôll slam this into ‚Äúlaunchable‚Äù mode. I‚Äôll give you exactly what to paste into the agent (so it picks up where it stopped) + bite-sized fixes and the exact code snippets you can paste into your frontend to get: planets sitting above the rocket inside one game box, faster wallet connect with MiniPay detection + wagmi fallback, immediate random landing animation (client-side until the contract resolves), Firebase integration steps, dependency installs, favicon change, and Vercel fixes.

Copy / paste the Agent Resume Prompt (below) into your Replit assistant so it continues from where it left off ‚Äî then paste the code snippets into the files I tell you and run the commands. Do not worry ‚Äî this is safe and focused only on code inside your repo.


---

1) AGENT: Resume prompt (paste to the Replit agent)

RESUME BUILD: RocketMint ‚Äî continue from where you stopped.

Priority tasks (do these now, in order):
1. Move the planet carousel so the planets render **above** the rocket and both are inside a single "GameSection" container/box. Make the box fixed-height on mobile with responsive scaling.
2. Speed up wallet connect UX:
   - Detect MiniPay environment (userAgent / window.navigator) and attempt MiniPay connect first.
   - If MiniPay is not available or connection is slow (>5s), fall back to wagmi (MetaMask / WalletConnect).
   - Add user-visible connect status and approximate timings.
3. Implement client-side prediction flow so the game is playable immediately:
   - After player picks a planet and confirms, run a 3s countdown, animate rocket, choose a random planet with deterministic pseudo-randomness (keccak256-style or seed+timestamp) and display result.
   - Emit a browser console log with the random seed and selection (for debugging).
   - Provide hooks for later switch to on-chain randomness/resolution (contract function names and event listeners).
4. Add Firebase boilerplate (Firestore) and create /firebase/init.ts that can be enabled by adding credentials in `.env.local`. Add `firebase/README.md` describing steps and security rules example.
5. Ensure Composer MCP & MiniPay MCP dependencies are installed. If missing, run MCP init commands and install required packages. Document any packages that need manual installation.
6. Replace default favicon with `public/favicon.ico` (rocket icon). If rocket ico not present, create a simple SVG-to-ICO placeholder and write `public/favicon.ico`.
7. Fix Vercel deploy config guidance: ensure `package.json` has correct build/start scripts and that Vercel's build command is `npm run build`. Document exact steps if the agent cannot set Vercel.
8. Produce a short commit summary and a `/docs/ISSUES.md` describing anything the agent could not finish automatically.

Files to modify/create: `/frontend/src/components/GameSection.tsx`, `/frontend/pages/_app.tsx` (or layout), `/frontend/public/favicon.ico`, `/firebase/init.ts`, `/docs/ISSUES.md`.

Start now and produce a short status log every time a task completes. Do not ask for human confirmation; flag placeholders in `.env.example`.

Use only the repo and approved docs. End.


---

2) Quick dependency installs (paste in Replit shell)

Run these in the repo root (adjust package manager if you use yarn/pnpm):

# frontend deps
cd frontend
npm install next react react-dom typescript tailwindcss postcss autoprefixer framer-motion ethers wagmi viem @wagmi/core @celo/contractkit firebase

# composer kit MCP (if not yet installed)
cd ..
npx @celo/composer-kit-mcp init || echo "MCP init may already exist"

# (optional) mini-pay lib - follow docs; add after checking official package name in docs
# npm install @celo/minipay-sdk   # only if present in official docs

If any package fails, paste the error into the chat and I‚Äôll help fix it.


---

3) GameSection component (planets above rocket in same box)

Create frontend/src/components/GameSection.tsx (TypeScript + Tailwind + Framer Motion). Paste this whole file:

// frontend/src/components/GameSection.tsx
import React, { useState } from "react";
import { motion } from "framer-motion";
import clsx from "clsx";

type Planet = {
  id: number;
  name: string;
  subtitle?: string;
  img?: string;
};

const PLANETS: Planet[] = [
  { id: 1, name: "Mercury", subtitle: "GAS" },
  { id: 2, name: "Venus", subtitle: "HODL" },
  { id: 3, name: "Earth", subtitle: "CELOVERSE" },
  { id: 4, name: "Mars", subtitle: "LFG" },
  { id: 5, name: "Jupiter", subtitle: "MINI" },
];

export default function GameSection() {
  const [choice, setChoice] = useState<number | null>(null);
  const [running, setRunning] = useState(false);
  const [result, setResult] = useState<Planet | null>(null);

  function deterministicRandomSeed(): string {
    // simple deterministic-ish seed using time and choice for demo
    return `${Date.now()}-${choice ?? "0"}`;
  }

  function pickRandomPlanet(): Planet {
    // Keccak-like deterministic client pseudo-random: use JS hash
    const seed = deterministicRandomSeed();
    // simple hash
    let h = 2166136261 >>> 0;
    for (let i = 0; i < seed.length; i++) {
      h ^= seed.charCodeAt(i);
      h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
    }
    const idx = Math.abs(h) % PLANETS.length;
    console.log("Seed:", seed, "Hash:", h, "Idx:", idx);
    return PLANETS[idx];
  }

  async function onConfirmPrediction() {
    if (choice === null) return;
    setRunning(true);
    setResult(null);
    // 3s countdown animation
    await new Promise((r) => setTimeout(r, 3000));
    const landed = pickRandomPlanet();
    setResult(landed);
    setRunning(false);
    // TODO: call contract resolve / emit event hook here
  }

  return (
    <section className="max-w-md mx-auto p-4">
      <div className="relative bg-gradient-to-b from-slate-900 to-slate-800 rounded-2xl shadow-xl overflow-hidden">
        {/* Planets area (top) */}
        <div className="p-4">
          <h3 className="text-sm text-slate-300">Choose a planet</h3>
          <div className="flex gap-3 overflow-x-auto py-3">
            {PLANETS.map((p) => (
              <button
                key={p.id}
                onClick={() => setChoice(p.id)}
                className={clsx(
                  "min-w-[110px] px-3 py-2 rounded-lg text-left",
                  choice === p.id
                    ? "bg-green-600/30 ring-2 ring-green-400"
                    : "bg-white/5 hover:bg-white/6"
                )}
              >
                <div className="text-white font-semibold">{p.name}</div>
                <div className="text-xs text-slate-300">{p.subtitle}</div>
              </button>
            ))}
          </div>
        </div>

        {/* Game Box: rocket + planets contained */}
        <div className="h-64 md:h-80 flex items-center justify-center relative">
          {/* decorative background */}
          <div className="absolute inset-0 pointer-events-none">
            <motion.div
              animate={{ opacity: [0.6, 0.9, 0.6] }}
              transition={{ duration: 6, repeat: Infinity }}
              className="w-full h-full bg-[radial-gradient(ellipse_at_center,_var(--tw-gradient-stops))] from-green-900/20 to-transparent"
            />
          </div>

          {/* Rocket container */}
          <div className="relative w-full max-w-sm h-full flex flex-col items-center justify-end px-6 pb-6">
            {/* planets floating near top of the box */}
            <div className="absolute top-6 left-1/2 -translate-x-1/2 flex gap-4">
              {PLANETS.map((p) => (
                <motion.div
                  key={p.id}
                  initial={{ y: -10 }}
                  animate={{ y: [ -6, 0, -6 ] }}
                  transition={{ duration: 2 + p.id * 0.2, repeat: Infinity }}
                  className="w-16 h-16 rounded-full bg-white/5 flex items-center justify-center text-xs text-white"
                >
                  {p.name.slice(0,3)}
                </motion.div>
              ))}
            </div>

            {/* Rocket */}
            <motion.div
              animate={running ? { y: [-10, -220] } : { y: 0 }}
              transition={{ duration: running ? 2.2 : 0.6 }}
              className="w-24 h-40 bg-gradient-to-b from-slate-100 to-slate-300 rounded-xl flex items-center justify-center"
            >
              <div className="text-black font-bold">üöÄ</div>
            </motion.div>

            {/* result / controls */}
            <div className="mt-4 w-full flex flex-col items-center">
              <div className="text-sm text-slate-300 mb-2">
                Selected:{" "}
                <span className="text-white">
                  {choice ? PLANETS.find(p => p.id === choice)?.name : "‚Äî"}
                </span>
              </div>

              <div className="flex gap-3">
                <button
                  onClick={onConfirmPrediction}
                  disabled={running || choice === null}
                  className="px-4 py-2 rounded-md bg-green-500 disabled:opacity-50"
                >
                  {running ? "Launching‚Ä¶" : "Confirm Prediction"}
                </button>
                <button
                  onClick={() => { setChoice(null); setResult(null); }}
                  className="px-4 py-2 rounded-md bg-white/5"
                >
                  Reset
                </button>
              </div>

              {result && (
                <div className="mt-3 p-3 bg-white/5 rounded-lg text-center text-slate-100">
                  <div className="font-semibold">Landed on {result.name}!</div>
                  <div className="text-xs text-slate-300">XP + Badge flow pending</div>
                </div>
              )}
            </div>
          </div>
        </div> {/* end game box */}
      </div>
    </section>
  );
}

This immediately ensures planets render visually above the rocket inside a single section box and gives you a working client-side prediction + animation loop.


---

4) Wallet connect logic ‚Äî detect MiniPay then fallback to wagmi

Create frontend/src/hooks/useWalletConnect.tsx (simplified hook). Paste:

// frontend/src/hooks/useWalletConnect.tsx
import { useEffect, useState } from "react";
import { createClient, configureChains, WagmiConfig } from "wagmi";
import { publicProvider } from "wagmi/providers/public";
import { useConnect, useAccount } from "wagmi";
import { InjectedConnector } from 'wagmi/connectors/injected';
import { WalletConnectConnector } from 'wagmi/connectors/walletConnect';

export function isMiniPayBrowser() {
  if (typeof navigator === "undefined") return false;
  const ua = navigator.userAgent || "";
  return ua.toLowerCase().includes("minipay") || ua.toLowerCase().includes("valora");
}

export function useWalletConnect() {
  const [preferred, setPreferred] = useState<"minipay" | "wagmi" | null>(null);
  const [status, setStatus] = useState("idle");

  useEffect(() => {
    if (isMiniPayBrowser()) setPreferred("minipay");
    else setPreferred("wagmi");
  }, []);

  // wagmi client (simple)
  const { chains, provider } = configureChains([], [publicProvider()]);
  const client = createClient({
    autoConnect: true,
    connectors: [
      new InjectedConnector({ chains }),
      new WalletConnectConnector({ chains, options: { qrcode: true } })
    ],
    provider
  });

  // export wrapper for components
  return { preferred, status, setStatus, client, isMini: preferred === "minipay" };
}

Usage: wrap your app with Wagmi provider in _app.tsx or Layout and use isMini to try MiniPay hooks first. If MiniPay connect call does not complete in 5s, call wagmi connect functions.


---

5) Faster wallet connect UX tips (implement in agent)

Try MiniPay connect first; start a 5s timer. If not connected in 5s, call wagmi.connect(). Show UI: ‚ÄúTrying MiniPay‚Ä¶ (5s) ‚Äî fallback ready‚Äù.

Use requestAnimationFrame to animate connect button and give user feedback.



---

6) Quick Firebase init (boilerplate)

Create firebase/init.ts:

// firebase/init.ts
import { initializeApp, getApps } from "firebase/app";
import { getFirestore } from "firebase/firestore";

const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY || "FIREBASE_API_KEY_PLACEHOLDER",
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN || "FIREBASE_AUTH_DOMAIN",
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID || "FIREBASE_PROJECT_ID",
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET || "",
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID || "",
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID || ""
};

export const initFirebase = () => {
  if (!getApps().length) {
    initializeApp(firebaseConfig);
  }
  return getFirestore();
}

Add firebase/README.md describing how to get credentials and create collection leaderboard.


---

7) Favicon (rocket)

Replace frontend/public/favicon.ico with a rocket icon. Quick way:

Create a 64√ó64 PNG or ICO with a rocket emoji or SVG converted to .ico.

If you don‚Äôt have a generator, paste this public/favicon.svg and set <link rel="icon" href="/favicon.svg" /> in head:


public/favicon.svg (simple):

<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24">
  <circle cx="12" cy="12" r="12" fill="#1ABC9C"/>
  <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" font-size="14">üöÄ</text>
</svg>

Then update _document or <head> in Next.js:

<link rel="icon" href="/favicon.svg" />


---

8) Vercel fix (why URL becomes download link & how to fix)

Common causes:

Your app was exported as static out folder but not built as Next app (App Router can't next export).

public served as a zipped file due to wrong build settings.

Headers set to Content-Disposition: attachment.


Fix checklist:

1. In frontend/package.json ensure:



"scripts": {
  "dev": "next dev",
  "build": "next build",
  "start": "next start",
  "lint": "next lint"
}

2. In Vercel project settings:

Framework Preset: Next.js

Build Command: npm run build

Output Directory: leave default (Vercel detects Next)



3. If you used next export before, remove it ‚Äî use next build + next start for App Router.


4. Re-deploy. If Vercel still returns a download, check vercel.json or server code for custom headers that add Content-Disposition. Remove them.



If the agent cannot set Vercel automatically, it must produce a /docs/VERCEL_FIX.md with these steps and exact build commands.


---

9) Hook for on-chain later

In your GameSection file add a TODO where to call submitPrediction(planetId) on contract and listen for PlanetLanded events to animate based on the on-chain result. The agent should create frontend/src/contract/hooks.ts with placeholders:

export async function submitPredictionToContract(planetId:number) {
  // TODO: implement contract call via @celo/contractkit or ethers
  // Example: contract.submitPrediction(planetId)
}
export function listenToRoundResult(callback: (planetId:number)=>void) {
  // TODO: listen to PlanetLanded event and call callback
}


---

10) Tell the agent to continue (exact sentence)

Paste into Replit assistant after the Resume prompt earlier:

Continue: implement the GameSection.tsx above, add the useWalletConnect hook, create firebase/init.ts, add favicon.svg, and generate docs/VERCEL_FIX.md and docs/ISSUES.md. After finishing, run frontend dev and show the host/port for preview. Prioritize making the gameplay functional client-side immediately.


---

11) If you need a fast on-chain demo (optional)

If you want a testnet ‚Äúreal‚Äù variant quickly, the agent can:

Deploy MiniRocketGame.sol with resolveRound() that accepts a pseudo-random seed input (owner-triggered) for demo. This lets you manually call resolveRound(seed) after players predict ‚Äî still on-chain, deterministic, and demo-safe.



---

12) Final quick checklist for you to run now

1. Paste the Agent Resume Prompt into Replit agent.


2. Paste GameSection.tsx into codebase file and import it into your main page.


3. Paste the useWalletConnect hook and wrap your app in Wagmi provider (or ask me to produce _app.tsx wrapper).


4. Run the install commands above.


5. Ask the Replit agent to run npm run dev and preview.


6. Fix Vercel by ensuring build scripts are correct, then redeploy with Build Command npm run build.




---

If you want I‚Äôll:

produce _app.tsx + Wagmi provider wrapper ready to paste,

or make the sample serverless endpoint pattern for secure MiniPay sending (Phase B),

or write the resolveRound Hardhat deploy script and a demo owner-call script.


Say which of those you want first and I‚Äôll output the exact file to paste. We‚Äôre in grind mode ‚Äî let‚Äôs finish this and get that playable prediction + rocket animation live. üöÄüî•